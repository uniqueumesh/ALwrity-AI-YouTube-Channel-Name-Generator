from __future__ import annotations

from typing import Dict, List, Optional
import httpx
import orjson


GENERATION_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent"


def _build_svg_prompt(name: str, style: str, style_prompt: Optional[str]) -> str:
    extra = f" Style details: {style_prompt}." if style_prompt else ""
    return (
        "Design a simple, clean, brandable LOGO as pure SVG markup (vector).\n"
        f"Channel name: '{name}'. Desired style: {style}.{extra}\n"
        "Constraints:\n"
        "- Flat design, high legibility, no photorealism.\n"
        "- Typography-centric logo with optional minimal geometric shape.\n"
        "- No external images, no scripts, no external references.\n"
        "- Viewbox 0 0 1024 512, responsive width/height.\n"
        "Output strictly as JSON with one field: svg (a single string containing the full <svg>...</svg>). No extra text."
    )


def generate_ai_logos(*, api_key: str, names: List[str], style: str, style_prompt: Optional[str], size_px: int = 1024) -> Dict[str, str]:
    """Return dict of name -> SVG string generated by Gemini.

    Using SVG avoids binary image parsing issues and renders reliably in Streamlit via HTML.
    """
    if not api_key:
        raise ValueError("Missing Gemini API key for AI logos")

    results: Dict[str, str] = {}

    with httpx.Client(timeout=45.0) as client:
        for n in names:
            prompt_text = _build_svg_prompt(n, style, style_prompt)
            payload = {
                "contents": [
                    {
                        "parts": [
                            {"text": prompt_text},
                        ]
                    }
                ]
            }
            params = {"key": api_key}
            resp = client.post(GENERATION_URL, params=params, json=payload)
            if resp.status_code != 200:
                continue
            data = resp.json()

            # Extract text parts and parse JSON with 'svg'
            text_blocks = []
            for candidate in data.get("candidates", []) or []:
                for part in (candidate.get("content", {}).get("parts", []) or []):
                    t = part.get("text")
                    if t:
                        text_blocks.append(t)
            raw_text = "\n".join(text_blocks).strip()
            if not raw_text:
                continue

            start = raw_text.find("{")
            end = raw_text.rfind("}")
            if start != -1 and end != -1 and end > start:
                json_str = raw_text[start : end + 1]
                try:
                    parsed = orjson.loads(json_str)
                    svg = (parsed.get("svg") or "").strip()
                    if svg and svg.lower().startswith("<svg") and svg.lower().endswith("</svg>"):
                        results[n] = svg
                        continue
                except Exception:
                    pass

            # If we didn't get valid JSON/SVG, skip this name (template fallback will still show)
            continue

    return results


